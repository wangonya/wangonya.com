#+title: Handling missing dict keys
#+author: Kelvin Wangonya
#+date: 2022-02-10T06:10:15+03:00
#+tags[]: python

Trying to access a non-existent key using this notation: =dict[key]=
raises a =KeyError=. An easy workaround for this is to use
=get(key)= instead, which returns =None= if =key= isn't found, or
=get(key, default)= which returns =default= if =key= isn't found.

#+begin_src sh
  >>> d = {}
  >>> d
  {}
  >>> d["x"]
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  KeyError: 'x'
  >>> d.get("x")
  >>> d
  {}
  >>> d.get("x","y")
  'y'
  >>> d
  {}
  >>>
#+end_src

But what if you want to not only return a default if the key is missing,
but also assign that default to the specified key in the dict? There are
a couple of ways to do that.

** 1. =setdefault=
   :PROPERTIES:
   :CUSTOM_ID: setdefault
   :END:

#+begin_quote
  =setdefault(key[, default])=
      :PROPERTIES:
      :CUSTOM_ID: setdefaultkey-default
      :END:
  If key is in the dictionary, return its value. If not, insert key with
  a value of default and return default. =default= defaults to =None=.

  [[https://docs.python.org/3/library/stdtypes.html#dict.setdefault][docs]]
#+end_quote

#+begin_src sh
  >>> d
  {}
  >>> d.setdefault("x","y")
  'y'
  >>> d
  {'x': 'y'}
  >>>
#+end_src

** 2. =defaultdict=
   :PROPERTIES:
   :CUSTOM_ID: defaultdict
   :END:

#+begin_quote
  =class collections.defaultdict(default_factory=None, /[, ...])=
      :PROPERTIES:
      :CUSTOM_ID: class-collections.defaultdictdefault_factorynone
      :END:
  The first argument provides the initial value for the
  [[https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory][default_factory]]
  attribute; it defaults to =None=. All remaining arguments are treated
  the same as if they were passed to the
  [[https://docs.python.org/3/library/stdtypes.html#dict][dict]]
  constructor, including keyword arguments.

  [[https://docs.python.org/3/library/collections.html#collections.defaultdict][docs]]
#+end_quote

#+begin_src sh
  >>> from collections import defaultdict
  >>> i = defaultdict(int)
  >>> i
  defaultdict(<class 'int'>, {})
  >>> i["x"]
  0
  >>> i
  defaultdict(<class 'int'>, {'x': 0})
  >>> i["y"]
  0
  >>> i
  defaultdict(<class 'int'>, {'x': 0, 'y': 0})
  >>>
#+end_src

Note that no =KeyError= is raised despite the key not existing at first.
Instead, the key is created with the default value of the type passed
into =defaultdict=, in this case =0= for =int=. If we used =list=
instead, the default value would be =[]=, an so on.

Further reading:

- [[https://docs.python.org/3/library/collections.html#defaultdict-examples][defaultdict
  Examples]]
- [[https://stackoverflow.com/questions/3483520/use-cases-for-the-setdefault-dict-method][Use
  cases for the 'setdefault' dict method]] (vs defaultdict)

** 3. Implement =__missing__=
   :PROPERTIES:
   :CUSTOM_ID: implement-__missing__
   :END:
This is actually what =defaultdict= does behind the scenes. Use this
when =defaultdict= doesn't fit your usecase.

#+begin_src sh
  >>> class M(dict):
  ...     def __missing__(self, key):
  ...             value = "my default value"
  ...             self[key] = value
  ...             return value
  ...
  >>>
  >>> m = M()
  >>> m
  {}
  >>> m["x"]
  'my default value'
  >>> m
  {'x': 'my default value'}
  >>> m["y"]
  'my default value'
  >>> m
  {'x': 'my default value', 'y': 'my default value'}
  >>>
#+end_src
